
import { useEffect, useState, useContext } from 'react';
import {
    Box, CardContent, CardHeader, Typography,
    Chip, List, ListItem, ListItemIcon, ListItemText,
    Accordion, AccordionSummary, AccordionDetails, Container, Button
} from '@mui/material';
import MemoryIcon from '@mui/icons-material/Memory';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import PsychologyIcon from '@mui/icons-material/Psychology';
import axiosInstance from '../AxiosInstance.jsx';
import { AuthContext } from '../Context/AuthContext.jsx';
import { useSnackbar } from '../Context/SnackBarContext.jsx';
import { AcUnit } from "@mui/icons-material";
import { useSocket } from "../Context/SocketContext.jsx";
import ReplyLoad from "../Components/ReplyLoad.jsx";

export default function Reflection() {
    const [reflection, setReflection] = useState(null);
    const [loading, setLoading] = useState(true);
    const [isMemorySearch, setIsMemorySearch] = useState(false);
    const [generatingReflection, setGeneratingReflection] = useState(false);
    const { user } = useContext(AuthContext);
    const socket = useSocket();
    const showSnackbar = useSnackbar();

    // socket events
    useEffect(() => {

        if (!socket) return;

        // memory search indicator
        socket.on("weekly-memory", (data) => {
            setIsMemorySearch(data.status);
        });

        // generating reflection indicator
        socket.on("generating-reflection", (data) => {
            setGeneratingReflection(data.status);
        });

        return () => {
            socket.off("weekly-memory");
            socket.off("generating-reflection");
        };
    }, [socket]);

    const fetchReflection = async () => {
        if (!socket || !socket.id) {
            return;
        }

        setLoading(true);
        try {
            const res = await axiosInstance.get(`/api/user/reflection/${user._id}`, { params: { socketId: socket.id } });
            setReflection(res.data);
        } catch (error) {
            console.error('Failed to fetch reflection:', error);
            showSnackbar(`Failed to fetch reflection : ${error.status} : ${error.response?.data?.message || error.message}`);
            setReflection(null);
        } finally {
            setLoading(false);
            setIsMemorySearch(false);
            setGeneratingReflection(false);
        }
    };

    useEffect(() => {
        fetchReflection();
    }, [user]);

    if (loading) return <ReplyLoad isMemorySearch={isMemorySearch} isReflectionGen={generatingReflection} />;

    if (!reflection) return (
        <Box mt={5} textAlign="center">
            <Button
                variant="contained"
                onClick={fetchReflection}
                sx={{
                    mt: 5,
                    px: 5,
                    py: 1.6,
                    fontSize: '1rem',
                    backgroundColor: '#0ca37f',
                    borderRadius: '30px',
                    textTransform: 'none',
                    fontWeight: 600,
                    '&:hover': {
                        backgroundColor: '#089a72',
                    },
                }}
            >
                <strong>Generate Reflection</strong>
            </Button>
        </Box>
    );

    return (
        <Container
            maxWidth="md"
            sx={{ width: { xs: '87vw', md: '60vw' } }}
        >
            <Box sx={{ backgroundColor: 'transparent' }}>
                <CardHeader
                    title="Weekly Reflection"
                    subheader="Generated by JARVIS"
                />
                <CardContent>
                    <Typography variant="h6" gutterBottom>
                        Summary
                    </Typography>
                    <Typography variant="body1" color="text.secondary">
                        {reflection.summary}
                    </Typography>

                    <Box mt={4}>
                        <Typography variant="h6" gutterBottom>
                            Themes
                        </Typography>
                        <Box
                            display="flex"
                            gap={1}
                            flexWrap="wrap"
                            justifyContent={{ xs: 'center', sm: 'flex-start' }}
                        >
                            {reflection.themes.map((theme, index) => (
                                <Chip
                                    key={index}
                                    label={theme}
                                    icon={<PsychologyIcon />}
                                    sx={{ backgroundColor: '#0ca37f', color: '#fff', mb: 1, mr: 1 }}
                                />
                            ))}
                        </Box>
                    </Box>

                    <Box mt={4}>
                        <Typography variant="h6" gutterBottom>
                            Suggestions
                        </Typography>
                        <List>
                            {reflection.suggestions.map((suggestion, index) => (
                                <ListItem key={index} sx={{ mb: 3 }} disablePadding>
                                    <ListItemIcon sx={{ minWidth: '40px' }}>
                                        <AcUnit sx={{ color: '#0ca37f' }} />
                                    </ListItemIcon>
                                    <ListItemText primary={suggestion} />
                                </ListItem>
                            ))}
                        </List>
                    </Box>

                    <Box mt={4}>
                        <Typography variant="h6" sx={{ mb: 2 }} gutterBottom>
                            Memories Reviewed
                        </Typography>
                        {reflection.memoriesUsed.map((mem, index) => (
                            <Accordion key={index} sx={{ mb: 3 }}>
                                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                                    <MemoryIcon sx={{ color: '#0ca37f', mr: 2 }} />
                                    <Typography >
                                        {mem.payload.text.length > 50
                                            ? mem.payload.text.slice(0, 80) + '...'
                                            : mem.payload.text}
                                    </Typography>
                                </AccordionSummary>
                                <AccordionDetails>
                                    <Typography variant="body2">
                                        {mem.payload.text}
                                    </Typography>
                                    <Typography
                                        variant="caption"
                                        color="text.secondary"
                                        sx={{ display: 'block', mt: 1 }}
                                    >
                                        Timestamp: {new Date(mem.payload.timestamp).toLocaleString()}
                                    </Typography>
                                </AccordionDetails>
                            </Accordion>
                        ))}
                    </Box>

                    <Box mt={5} textAlign="center">
                        <Button
                            variant="contained"
                            onClick={fetchReflection}
                            sx={{
                                mt: 3,
                                px: { xs: 3, sm: 5 },
                                py: 1.6,
                                fontSize: { xs: '0.9rem', sm: '1rem' },
                                backgroundColor: '#0ca37f',
                                borderRadius: '30px',
                                textTransform: 'none',
                                fontWeight: 600,
                                '&:hover': {
                                    backgroundColor: '#089a72',
                                },
                            }}
                        >
                            <strong>Generate again</strong>
                        </Button>
                    </Box>
                </CardContent>
            </Box>
        </Container>
    );

};
